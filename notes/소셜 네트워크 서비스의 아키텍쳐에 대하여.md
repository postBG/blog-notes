# 소셜 네트워크 서비스의 아키텍쳐에 대하여

## 요약

Facebook은 게시판(pull), 트위터는 이메일(push) 아케텍쳐를 기본으로 하여 발전하면서 둘의 아키텍쳐는 상이한 발전 형태를 가지게 되었다.

Facebook은 기본적으로 게시판과 비슷한 형태를 가지게 되면서 친구들의 소식을 모아볼 때(pull), 즉, 읽기 연산 중에 다양한 행동을 해야하는 형태를 가지게 되었다. 따라서, 친구들을 검색하고 친구가 최근에 작성한 글을 긁어오는 동안 계산 복잡도를 많이 신경써야하는 형태가 되어 다양한 cache 방식을 도입하게 되었고, '좋아요', '글쓰기' 등 다양한 액션을 지원하기 위해 TAO로 발전하게 되었다. 부가적으로 피드가 인기글 순서인 경우는 그것이 UX적으로 말이 되기도 하지만, 계산량을 줄이는 한가지 좋은 방법이 되기도 하기 때문이다. 즉, 인기있는 사람이 쓴 글을 우선적으로 계산하면 많은 양의 계산을 줄일 수 있다.

트위터의 경우. 페이스북과는 다른 성격의 서비스로 내가 팔로잉하는 사람이 글을 쓰면, 그 글을 내가 유입하면 받아볼 수 있는 것인데, 이는 기존의 이메일과 같이 Async Push 서비스와 비슷한 형태이다. 따라서 페이스북과는 달리 이러한 Push받은 트윗 목록을 저장해둘 공간이 필요해지게 되고, 결국 공간복잡도라는 도전에 직면하게 된다. 트위터는 이를 Cache와 그 Cache를 찾기 위한 메커니즘을 통해 해결하게 되었다.



## 기술적인 면에서 새로 배운 것

* 프로그래밍 가능한 캐시
  * Facebook에서 특정 사용자의 글을 보여주는 경우에 발생하는 피드 관련 연산을 최적화하는 과정에서 DB수준의 캐시를 사용하면 다른 많은 연산들과 섞이면서 DB가 별로 쓰이지 않는 블록을 캐시하는 경우가 생겨 성능에 문제가 생길 가능성이 있음. 따라서 프로그래밍 가능한 캐시를 사용하게 되었고, LAMP 스택에서는 memcached의 look-ahead 스택을 이용한다고 함.


* 분산 클러스팅 환경에서의 해싱
  * 분산 클러스터를 구성하면 엔티티를 검색하고 저장하는 것에 문제가 생기게 됨은 알고 있었다.
  * 이를 해결하는 방법은 (역시나) Hash를 이용한 검색인데, 아래의 세가지 방식이 있고, 이 글에서 Facebook은 마지막 방식을 사용한다고 함.
    * 어떤 서버에 데이터가 있는지 하나하나 관리: 주소의 유연성이 있지만 그 유연성을 지탱할 거대한 저장소가 필요
    * 해시 함수를 사용해 해시 결과가 해당 서버로 바로 안내: 단순하고 저장소가 필요 없지만 유연성이 떨어짐
    * 둘의 장점을 혼합해 제공하는 consistent hashing: 각 데이터의 저장소 주소를 저장하기보다 한정된 전체 주소를 여러 범위로 나누어 각 저장소에 대응시켜 사용하는 방식



## 앞으로 할 일

이 글에 링크된 Yahoo!의 논문과 Facebook의 TAO에 대한 글을 읽어봐야겠다.

그리고 트랙백, look-ahead 캐시처럼 모르는 단어도 좀 찾아봐야겠음.